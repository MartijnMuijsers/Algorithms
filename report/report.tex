\documentclass[11pt]{article}

\usepackage{amsmath,amssymb}
\usepackage{a4wide}
\usepackage{graphicx}

\newcommand{\maxsize}[1]{\begin{quotation} {\sl \noindent Maximum size: #1.} \end{quotation}}

\newcommand{\crp}[1]{\begin{quotation} {\sl \noindent For the curve- and network-reconstruction problem: #1} \end{quotation}}

\newcommand{\example}[1]{\begin{quotation} {\sl \noindent Example: #1} \end{quotation}}

%%
% Theorem-Like Environments
%
\newtheorem{defin}{Definition}
  \newenvironment{mydefinition}{\begin{defin} \sl}{\end{defin}}
\newtheorem{theo}[defin]{Theorem}
  \newenvironment{mytheorem}{\begin{theo} \sl}{\end{theo}}
\newtheorem{lem}[defin]{Lemma}
  \newenvironment{lemma}{\begin{lem} \sl}{\end{lem}}
\newtheorem{coro}[defin]{Corollary}
  \newenvironment{corollary}{\begin{coro} \sl}{\end{coro}}
\newtheorem{obse}[defin]{Observation}
  \newenvironment{observation}{\begin{obse} \sl}{\end{obse}}

\newenvironment{proof}{\emph{Proof.}}{\hfill $\Box$ \medskip\\}

% TODO(robwu): Choose a more descriptive title
\title{2D curve and network reconstruction}
\author{
A. van den Boogaart \and
W. Brouwer \and
C. Mens \and
M. Muijsers \and
R. Wu
}
\date{\today}

\begin{document}

\newpage

\maketitle

\begin{abstract}
We present three algorithms that connect all nodes in an unorganised set in the 2D plane in an aestetically pleasing manner. 
The first algorithm will reconstruct a set of nodes into a single curve, such that no lines intersect. 
The second algorithm will create multiple curves from the set of nodes, also in such a way that no lines intersect. 
The third and final algorithm will attempt to create a road network from the nodes, and can add additional nodes when intersections occur.\\

\end{abstract}

\section{Introduction}
\label{se:introduction}
\maxsize{2 pages}
The problem that we attempt to solve is that of reconstructing a set of points back into curves in the 2D plane. 
This problem is split into three different parts. The first two require the reconstruction of a set of points into curves, in the first case there is only one curve, whereas in the second case there are mutiple. The third part of the problem requires reconstructing to a road network.\\
This means that in the second case it is also required to distinguish multiple different curves from each other.\\
 It is important to note that the points are not given in order, since the goal is for the algorithm to determine the order, after which we can connect these points to reconstruct the curve.\\
 The multiple curve problem has the additional problem of finding out which points belong to which curve.\\
 Both algorithms have some constraints; Curve segments should not intersect each other and all points in the input must be used in the curve.\\
The third part of the problem requires reconstruction of a road network. This algorithm could be used to create a road map after data has been collected using the GPS locations of cars.\\
The goal of the algorithm is to create a reasonable representation of the road network, such that a person would agree with the representation that the algorithm gives. As with the other algorithms, there are some constraints.\\
All points need to have at least one possible path to every other point and lines cannot intersect one another, however, unlike with the other problems, points can be added to alleviate intersecting lines.\\
All nodes are points in a 2D plane, given by floating points ranging from 0 to 1. 
The nodes are not determined randomly, but are determined beforehand. In practice, these datasets can be created by laser scanners, or in the case of the network, by following roads and giving the location at some interval.\\

%TODO: Redo algorithms to represent actual solutions.
There are multiple known solutions to these problems. One of these is 'The Crust Algorithm'[1], which first creates a Volonoi diagram, then uses Delaunay triangulation between the Volonoi diagram and the Volonoi vertices.\\
The Crust Algorithm solves the first problem that is described above, but needs additional work to determine the multiple curve problem.\\
The running time of the Crust algorithm is dominated by the Delaunay triangulation. 
Deleaunay triangulation has a worst case running time of $nlog(n)$ when using the Divide and Conquer method described by Guibas and Stolfi [2].\\
Delaunay triangulation can also be used to create a relatively small set of edges for the third problem, after which a recilinear spanning graph or straight lines can be determined between points. These straight lines can then be connected to form a road network.\\

% TODO: Remove introduction description

The introduction usually starts with a description of and
a motivation for the general problem area.
%
\crp{You would start by
describing the general problem of object reconstruction from point data,
mention how data can be obtained (laser scanners), discuss network reconstruction, etcetera.}
%
After introducing the general problem area, you zoom in to the specific problem
studied in the paper. I like to already discuss previous work here. This way
you can explain where the specific problem fits into the state-of-the-art
and why it is interesting. Ideally, the discussion of the previous work
culminates in a clear statement about what is still missing in the current
state-of-the-art: namely an answer to the specific problem you study.
%
\crp{You would now discuss the specific variants that you study, 
what is known about them, which general reconstruction methods may or may not apply, and so on.}
%
Then you give an overview of your results.
%
\crp{You could give a high-level description of the
approach(es) you have used and relate them to approaches found in the literature.
State the theoretical guarantees (on running time,
for instance, or on other aspects) that you may have proved for your algorithms
and mention the main conclusions from the experiments.}
%
Finally, you can give an overview of the structure of the rest of your paper.
Personally, however, I do not find these overviews very useful: I prefer to
integrate this with the previous part of the introduction, where the overview
of the results is given.

%TODO: Remove until here

\section{The algorithms}
\label{se:algorithms}
\maxsize{8 pages. Use subsections where appropriate.}
%TODO: Add algorithm descriptions
\subsection*{Single curve reconstruction}
The algorithm to reconstruct a single curve randomly starts at a point. Then it will look at all possible points and picks the one that is most likely, and continues doing this until all points are visited.\\
If the algorithm cannot find a next point that seems logical, it will return to the previous point and pick the next most likely point to go to.\\
Every cycle the algorithm determines a value for all unvisited points based on the angle from the line segment constructed in the previous cycle and the distance.

\subsection*{Multiple curve reconstruction}

\subsection*{Network reconstruction}
To reconstruct a network from a set of points, we start by creating a minimum spanning tree between all points using Kruskal's algorithm.\\
After this we look for straight lines in this new set of points, and check if continuing this line will result in intersections. If they do intersect within a certain distance, then we can connect these lines by adding an additional point to create an intersection.\\

%TODO: Remove project guidelines
\subparagraph*{Project guide}
The description of the algorithms should be such that a programmer can
implement them without much difficulty. It is good practice to first explain the
main ideas behind the algorithm at a more intuitive level, and then give a
detailed description (for example using pseudo-code).
Don't forget to describe which supporting data structures you use:
linked lists, arrays, search trees, and so on. For standard data structures
from the literature you do not need to explain how they work; a reference
to the literature suffices.
%
\example{We store the set $P$ of points in a red-black tree~\cite{clrs-ia-01},
         using the $x$-coordinate of each point as its key.}
%
Try to theoretically analyze the worst-case running time of your algorithms
and the amount of storage they use. Also try to say something about the quality of your algorithm: you might
be able to prove that the algorithm is guaranteed to find the correct solution if the
input has certain well-defined properties, or you might be able to give examples
of inputs for which the algorithm will fail to give a correct solution.
%TODO: Remove until here

\bibliographystyle{plain}

\begin{thebibliography}{}

\bibitem{a-raoa-02}
S. Albers.
On randomized online scheduling.
In \emph{Proc. 34th ACM Sympos. Theory Comput.}, pages 134--143, 2002.

\bibitem{clrs-ia-01}
T.H. Cormen, C.E. Leiserson, R.L. Rivest and C. Stein.
\emph{Introduction to Algorithms} (2nd edition).
MIT Press, 2001.

\bibitem{m-apca-83}
N. Megiddo.
Applying parallel computation algorithms in the design of serial algorithms.
\emph{J. ACM} 30: 852--865 (1983).

\end{thebibliography}


\begin{itemize}
\item for journals:
      Authors. Title of paper. \emph{Journal Name (italic)} volume: page numbers (year).
      See reference~\cite{m-apca-83}.
\item for conference proceedings:
      Authors. Title of paper. In \emph{Proc. Conference Name and number (italic)}, pages xxx--yyy, year.
      See reference~\cite{a-raoa-02}
\item for books: Authors. \emph{Book title (italic)}. publisher, year.
      See reference~\cite{clrs-ia-01}
\end{itemize}






\end{document}

