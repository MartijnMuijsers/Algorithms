\documentclass[11pt]{article}

\usepackage{amsmath,amssymb}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{parskip}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{gensymb}

\newcommand{\maxsize}[1]{\begin{quotation} {\sl \noindent Maximum size: #1.} \end{quotation}}

\newcommand{\crp}[1]{\begin{quotation} {\sl \noindent For the curve- and network-reconstruction problem: #1} \end{quotation}}

\newcommand{\example}[1]{\begin{quotation} {\sl \noindent Example: #1} \end{quotation}}

%%
% Theorem-Like Environments
%
\newtheorem{defin}{Definition}
  \newenvironment{mydefinition}{\begin{defin} \sl}{\end{defin}}
\newtheorem{theo}[defin]{Theorem}
  \newenvironment{mytheorem}{\begin{theo} \sl}{\end{theo}}
\newtheorem{lem}[defin]{Lemma}
  \newenvironment{lemma}{\begin{lem} \sl}{\end{lem}}
\newtheorem{coro}[defin]{Corollary}
  \newenvironment{corollary}{\begin{coro} \sl}{\end{coro}}
\newtheorem{obse}[defin]{Observation}
  \newenvironment{observation}{\begin{obse} \sl}{\end{obse}}

\newenvironment{proof}{\emph{Proof.}}{\hfill $\Box$ \medskip\\}

% TODO(robwu): Choose a more descriptive title
\title{2D curve and network reconstruction}
\author{
A. van den Boogaart \and
W. Brouwer \and
C. Mens \and
M. Muijsers \and
R. Wu
}
\date{\today}

\begin{document}

\newpage

\maketitle

\begin{abstract}
In this study  two formulations of solutions to effectively solve the problem of connecting a set of nodes in the 2D plane in an aesthetically pleasing manner, and one formulation of a solution for reconstructing a road network from a set of nodes in the 2D plane are proposed.
The first proposed solution reconstructs these nodes into a single curve.
The second proposed solution will yield a similar result as the first solution, but will distinguish multiple curves from one another.
The third proposed solution attempts to create a road network from nodes. This problem is distinct from the other two, as here the challenge lies in creating intersections, instead of avoiding them.

\end{abstract}

\section{Introduction}
\label{se:introduction}
The to be presented algorithms will solve the problem of reconstructing curves for a given set of points in the 2D plane. This problem has three slightly different forms: The first two require the reconstruction of a set of points into curves, in the first case there is only one curve, whereas in the second case there are multiple. The third part of the problem requires reconstructing to a road network.

To be able to focus on a specific type of curve reconstruction, we will only consider curves where all points in the input are used and where line segments do not intersect each other.

The goal of the road network algorithm is to create a reasonable representation of the road network, such that a person would agree with the representation that the algorithm gives. This algorithm could be used to create a road map from the given data.

As with the other two algorithms, we have created some constraints for the road network to be able to focus on specific input. All points need to have at least one possible path to every other point and intersecting lines need an additional node at the intersection. The nodes are points in a 2D plane. In practice, the generation of nodes can be done by laser scanners, or in the case of the road network, by following roads and giving a gps location at certain intervals. 

There are multiple known solutions to these problems. One of these is `The Crust Algorithm' \cite{crust}, which first creates a Voronoi diagram, then uses Delaunay triangulation between the Voronoi diagram and the Voronoi vertices. The Crust Algorithm works well in three dimensions, but has difficulty with detecting sharp corners which are common in two dimensional reconstruction.
A different algorithm, specifically made for two dimensional reconstruction is `Gathan' \cite{gathan}. This provides a good solution for general cases, but does not allow for selecting multiple or single curves and relies on difficult mathematical graphs.
DISCUR \cite{discur} is another algorithm solving the curve reconstruction problem. It has no parameters, but requires dense sampling points to recontruct correctly.
For the network problem there exists a road network reconstruction algorithm \cite{chen} which obtains subcurves by creating a voronoi diagram.

Delaunay triangulation \cite{delaunay} could possibly be used to create a relatively small set of edges for the third problem, after which a rectilinear spanning graph or straight lines can be determined between points. This will improve efficiency, as it has a running time of $O(n \log{n})$, whereas Kruskal's algorithm will check all possible edges initially, resulting in $O(n^2 \log{n})$.

For the single curve reconstruction problem, we have also looked at the convex hull \cite{convex}. A convex hull will create segments between all the outermost points, such that no unconnected point is outside of the enclosed area. Like putting a rubber band around all the points. This is useful for the outermost nodes, but does not do anything with the nodes inside this outline.

For solving these three problems, we present an algorithm for each problem.
To solve the single curve reconstruction problem, the algorithm creates a convex hull and then continues by removing the largest edge and then reconnecting the figure by creating 2 new segments with another nearby point.
Multiple curves are solved using a seperate algorithm, which first connects the shortest segments such that there are no intersecting lines, after which it will seek out sharp angles and tries to remove and replace these with obtuse angles.
The road network reconstruction problems is solved using a minimum spanning tree. After reconstructing this tree, the algorithm finds nodes with degree 1 and connects these to a nearby node. To correctly create intersections, nodes with degree 3 or higher will check their surrounding segments and will add a point based on their angles.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.3]{images/outputOverview.png}
\caption{Output of the single curve (Left), multiple curve (Middle) and Network (Right) reconstruction algorithms.}
\label{outputOverview}
\end{figure}$ $\\


\section{The algorithms}
\label{se:algorithms}
\subsubsection{Background definitions}
Let $U = [0,1]^2$ be a set of points in a two-dimensional space.
For any $u,v \in U$, the line segment between $u$ and $v$ is denoted as $s_{u,v}$. $u$ and $v$ are called the endpoints of $s_{u,v}$. Each of the presented algorithms take $P \subset U$ as input, and output $S \subset \{s_{p,q} | p,q \in P \land p \neq q \}$.
 Two distinct points $a$ and $b$ are called \textit{connected} if there is a segment in $S$ whose endpoints are $a$ and $b$.
 Two segments are \textit{intersecting} each other if the line segments have a common point besides than the endpoints.
%TODO (rob): The next line does not belong here, it's a detail specific to the algorithm, right?
%None of these output line segments intersect another line segment in $S$.

For any $p,q \in U$, $d(p,q)$ is the Euclidean distance between $p$ and $q$. %\ref{todo:euclid_distance}.

For every $p \in P$ and $n \in \mathbb{N}$, $Adj_{p,n}$ is an adjacency list consisting of the $n$ nearest points to $p$, sorted in ascending order.

For any $p \in P$, the degree of $p$ denoted by $deg(p)$ is the number of line segments that are connected to $p$.

$\varphi(s_{u,v}, s_{v_w})$ is the absolute value of the smallest angle between two segments that share a common point,
If $p \in P$ has degree two, then $\alpha_p$ is defined to be the absolute value of the smallest angle between its two connected segments. %TODO What if degree is not two?



\subsection{Single curve reconstruction}
%TODO Martijn: check definitions at previous section and describe algorithm. Stick to the conventions and styles introduced used in the next two sections!

\subsection{Multiple curve reconstruction}
\subsubsection{Description}
For a given set of $n$ points $P \subset U$, this algorithm generates a set of non-intersecting line segments $S$ such that for every point, its degree is at most two. This result is generated in two steps. The segments in $S$ connect points in $P$ and form one or more shapes.

During both steps, two invariants are maintained:%
\noindent\begin{enumerate}\topsep=0pt\itemsep=0pt\parsep=0pt
\item $\forall p \in P : deg(p) \leq 2$
\item The segments in $S$ do not intersect each other.
\end{enumerate}

%First, a set of segments is generated from the input. From this set, the shortest segments are selected and added to $S$ if the invariants are not invalidated. More precisely:

%TODO Arjan said that it would be a good idea to first explain how T is generated before stating how it is used.
Let $T \subset \{s_{p,q} | p,q \in P \land p \neq q \}$. A segment $s_{shortest}$ is said to be the shortest segment if there is no other segment in $T$ whose length is smaller than the length of $s_{shortest}$.
While $T$ is not an empty set, find $s_{shortest}$ and remove it from the set and add $s_{shortest}$ to $S$ if doing so does not invalidate the invariants. Repeat this step until $T$ is empty.
%TODO Early termination is also possible when $S$ has $n$ elements.

%TODO Justify previous method.

The elements for set $T$ can be generated in two ways. A straight-forward approach is to create a list of all possible segments, sort the list and iterate through it. The number of possible segments is $(n-1)^2$, so the memory complexity is $O(n^2)$. Sorting time is linearithmic in terms of the number of elements to sort, so the time complexity is $O(n^2\log(n))$.

A quadratic complexity for memory is highly undesirable, because most computer systems have a limited amount of memory. To reduce the memory requirements, the first step can also be calculated using the following alternative method. For each point $p \in P$, find the $m$ nearest points and store the segments that are constructed from these points in a list. Then as before sort the list and iterate through its elements.

With this alternative method, the memory complexity is reduced to $O(mn)$. The $m$ nearest points can be found in $O(mn)$ time with partial selection sort.
%TODO Add reference for partial selection sort.
 $mn$ segments will thus be generated in $O(mn^2)$ time and sorted in $O(mn\log(mn))$ time. If $m$ is a (small) constant, then the memory complexity is $O(n)$ and the time complexity is $O(n\log(n))$. This is a huge improvement over the previous algorithm! The disadvantage of this method over the previous is that a dense cluster of $m$ points will never be connected to other points and leave gaps in a curve.

This first step only accounts for the lengths of the segments, not for any other properties of the shapes in the graph, such as the angle between two segments. Consequently, there may be points with two connected segments that have a small angle. An initial experimental evaluation showed that this first step of the algorithm yields a reasonable solution, but tends to create small and disconnected shapes. This is not surprising, because in a sparse graph nodes in a corner are often close to each other. Consequently, the segments of the initial solution often form a set of small shapes, as seen in figure \ref{fig:multiple_initial_solution}.

\begin{figure}[hbtp]
\centering
\begin{subfigure}{.33\linewidth}
  \centering
  \includegraphics[width=0.9\linewidth]{multiplecurves/algo_step0_dots.pdf}
  \caption{Input}
\end{subfigure}%
\begin{subfigure}{.33\linewidth}
  \centering
  \includegraphics[width=0.9\linewidth]{multiplecurves/algo_step1_add_lines_with_numbers.pdf}
  \caption{Initial solution}
\end{subfigure}%
  \caption{Input and output of the multiple curve algorithm's first step.}
\label{fig:multiple_initial_solution}
\end{figure}

In the next step, disconnected shapes are joined if possible, by replacing segments in $S$ that are part of a corner with a sharp angle. Since the previous step yields a good initial solution, most of the segments will not be modified, so the angles at the endpoints of most segments will not change. This observation is important, because replacing a segment affects the angles of the segments that are connected to the former and new endpoints of the replaced segment, which could invalidate a previous calculation that relied on the angles.

For every $p \in P$ where $deg(p) = 2$, select $p$ for the next step of the algorithm if $\alpha_p < \alpha_{required}$. $\alpha_{required}$ is a parameter that is used to determine whether an angle is considered to be too sharp. It is set to $90\degree$.

For each of the selected points, try to replace a segment as follows:

\begin{enumerate}
\item Let $p_1$ be the selected point, and $s_{p_1,p_2}$ be the longest segments that is connected to $p_1$. The other segment is connected to $p_3$.
\item Select the best point from $Adj_{p_1,10}$. The best point is found by following the next steps for each $q_1 \in Adj_{p_1,10}$.
  \begin{enumerate}
  \item If $deg(q_1) = 0$, then $q_1$ is not the best point.
  \item Let $q_2$ be a point that is connected with $q_1$. If $deg(p_1) = 2$, repeat the same steps from here for the endpoint of the other segment.
  \item If $\varphi(s_{p_1,p_3}, s_{p_1,q_1}) < \alpha_{sharp}$, then $q_1$ is not the best point. $\alpha_{sharp}$ is a parameter that specifies the minimum required angle. This step exists to prevent inserting sharp corners again. This parameter is typically lower than $\alpha_{required}$ and is set to $45\degree$.
  \item If $d(p_1, q_1)$ and $d(p_2,q_2)$ are both greater than $d(p_1,p_3) \cdot \lambda$, then $q_1$ is not the best point.
  This step ensures that a segment is not replaced by segments that are significantly shorter.
  Parameter $\lambda$ is set to $1.2$ to allow points that result in a slightly shorter segment to be considered as best point.
  \item If $s_{q_1,q_2}$ is already in $S$, and (indirectly) connected to $p_1$, then $q_1$ is not the best point. This step exists to avoid breaking shapes in even smaller shapes. Since the degree of every point is at most two, this can easily be checked by enumerating the segments in the paths originating from $p_1$.
  \item If any of the new segments intersect each other or other segments in $S$ (besides the to-be-removed ones), then $q_1$ is not the best point.
  \item Otherwise, $q_1$ is the best point if $d(p_1,q_1) + d(p_2,q_2) - d(p_1,p_2) - d(q_1,q_2)$ is minimal (relative to all other $q \in Adj_{p_1,10}$), \textit{and} greater than $\textsc{minWeight}$. This parameter specifies the threshold for the weight. A positive value means that the sum of the new segment's lengths must be smaller than the existing segments, while a negative value means that the sum is allowed to be bigger. $\textsc{minWeight}$ is set to $-0.2$.
  \end{enumerate}

\item If the best point $q_1$ exists, remove $s_{p_1,p_2}$ and $s_{q_1,q_2}$ from $S$, and add $s_{p_1,q_1}$ and $s_{p_2,q_2}$ to $S$.
\item Otherwise the longest segment cannot be replaced, so check whether the shortest segment can be replaced by repeating these steps with the shortest segment instead of the longest one.
\end{enumerate}


The meaning and relations between $p_1$, $p_2$, $p_3$, $q_1$ and $q_2$ are displayed in figure \ref{fig:multiple_pppqq}.
Let $n$ be the size of $P$. Since $|S| \leq |P|$, $|P| = O(n)$.
In the worst case, the algorithm checks for each segment whether it needs to be replaced. At each check, the best choice is select among the 10 nearest points (found in linear time using partial selection sort). This takes $O(n)$ time, because after spending a constant amount of time on determining the weight, $O(n)$ time is required to check for intersections. Thus the time complexity is $O(n^2) = O(n^2)$. The storage complexity is constant.

If the first method of step 1 is used, then the full algorithm requires $O(n^2)$ storage and $O(n^2\log(n))$ time. If the alternative method is used, then the algorithm runs in $O(n^2)$ time using $O(n)$ storage.

\begin{figure}[hbtp]
\centering
\begin{subfigure}{.33\linewidth}
  \centering
  \includegraphics[width=0.9\linewidth]{multiplecurves/algo_replace_segment.pdf}
  \caption{Initial solution}
\end{subfigure}%
\begin{subfigure}{.33\linewidth}
  \centering
  \includegraphics[width=0.9\linewidth]{multiplecurves/algo_final.pdf}
  \caption{Final solution}
\end{subfigure}%
  \caption{$s_{p_1,p_2}$ and $s_{q_1,q_2}$ is replaced with $s_{p_1,q_1}$ and $s_{p_2,q_2}$.}
\label{fig:multiple_pppqq}
\end{figure}


\subsection{Network Algorithm}
%TODO Chris: Insert content of network2.tex.

\section{Experimental evaluation}
\subsection{Generating input}
To properly test the presented algorithms, many test cases have been created. The majority of these test cases were created by hand, made to be as difficult as possible for the algorithms. Some have sharp corners, or have points with large gaps between them as shown in figure \ref{single}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.2]{anglesamplerate.png}
\caption{Test case with low sampling and a sharp angle (left) and the resulting output from the single curve algorithm (right.)}
\label{single}
\end{figure}

Other test cases have been created to test the running time of the algorithm, with the amount of nodes ranging from $100$ to $10000$. This same input is then used on all algorithms.

\begin{table}[ht!]
    \begin{tabular}{lrrrrr}
    ~                       & 100 nodes & 500 nodes & 1.000 nodes & 5.000 			nodes & 10.000 nodes \\
    Single Reconstruction   & 33ms      & 126ms     & 782ms       & 3.985ms     	& 20.604ms     \\
    Multiple Reconstruction & 38ms      & 146ms     & 207ms       & 2.947ms     	& 7.387ms      \\
    Network Reconstruction  & 18ms      & 85ms      & 143ms       & 1.996ms     	& 4.802ms      \\
    \end{tabular}
\caption{Table showing the computing time required for different input sizes.}
\end{table}

The multiple curve algorithm has additional test cases that are not run by the single curve algorithm, made specifically to test whether it correctly distinguishes between the multiple curves. These include curves enclosed in another curve, some curves that are close to each other and multiple curves that spiral around each other, some examples of these test cases are given in figure \ref{multi}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.3]{multiInput.png}
\caption{A collection of test cases specifically for the multiple curve algorithm, with the correct output displayed to the right of it.}
\label{multi}
\end{figure}

The network algorithm has different input than the other two given curve reconstruction algorithms, so it therefore also requires specific test cases. For this, test cases have been modeled after real life road maps. Some test have also been created to test specific parts of the algorithm, for instance a inputs that has close parallel lines, merging roads and roundabouts.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.3]{networkInput.png}
\caption{A large intersection to test for parrallel and merging lines (Left) Simple neighbourhood (Right)}
\label{network}
\end{figure}$ $\\

\subsection{Resulting output}
Dingen die je erin kan zetten:\\
Parameters, input sizes, sampling conditions, wat niet werkt en waarom niet, allemaal met plaatjes/tabellen erbij. Geef ook aan hoe je de werking van het algoritme kan zien in de output.

\subsubsection{Single curve}

\subsubsection{Multiple curves}
The accuracy of the multiple curve algorithm relies on the effectiveness of the initial solution. The description provided two ways to reach the initial solution. The original method is relatively expensive, so the alternative method was made available to make the algorithm feasible for bigger input sizes. In the next section, the experimental results of the initial solution are evaluated. Then, the transformation from the initial solution to the final solution is evaluated.

\subsubsection*{Multiple curves: Initial solution}
%TODO Compare n^2 with 10n method
%TODO Test case: Dense = GOOD
%TODO Test case: Dense square with sparse outer square, n^2 = GOOD, 10n = BAD
%TODO Test case: sparse paralel = BAD
%TODO Test case: square/circle with lonely point in middle = GOOD
%TODO Dense line with odd gaps = BAD/GOOD

\subsubsection*{Multiple curves: Final solution}
%TODO Parameters $\alpha_{required}$ and $\alpha_{sharp}$ (briefly)
%TODO Parameter $\lambda$ (=length multiplier)
%TODO Parameter \textsc{minWeight}
%TODO Parameter 10 in $Adj_{p_1,10}$ - why 10?
%TODO (not documented in algo) Parameter 5f that determines closeness? 197-203 in MultipleCurves.java

%TODO Test case: Triangle in corner = GOOD
%TODO Test case: Paralel = OKAY (mention the undocumented feature?)
%TODO More test cases?

\subsubsection{Network reconstruction}

\subsection{Conclusion}

\section{Concluding remarks}


\subsection{Future Work}
\bibliographystyle{plain}

\begin{thebibliography}{50}

\bibitem{crust}

Amenta, Nina, Marshall Bern, and Manolis Kamvysselis. 
"A new Voronoi-based surface reconstruction algorithm." 
\textit{Proceedings of the 25th annual conference on Computer graphics and interactive techniques}, 1998.

\bibitem{kruskal}
J.B. Kruskal.
On the shortest spanning subtree of a graph and the traveling salesman problem.
In \emph{Proceedings of the American Mathematical Society},7: 48-50, 1956.

\bibitem{chen}
D. Chen, L.J. Guibas, J. Hershberger, J. Sun.
Road Network Reconstruction for Organizing Paths.
In \emph{Proceedings  of  21st  ACM-SIAM  Symposium  on  Discrete  Algorithms}, 10: 1309-1320, 2010.

\bibitem{discur}
Zeng, Yong, et al. "A distance-based parameter free algorithm for curve reconstruction." \textit{Computer-Aided Design} 40.2: 210-222, 2008 .

\bibitem{gathan}
Dey, Tamal K., and Rephael Wenger. "Reconstruction curves with sharp corners." \textit{Proceedings of the sixteenth annual symposium on Computational geometry.} ACM, 2000.

\bibitem{delaunay}

\bibitem{convex}


\end{thebibliography}







\end{document}
