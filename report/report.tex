\documentclass[11pt]{article}

\usepackage{amsmath,amssymb}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmic}

\newcommand{\maxsize}[1]{\begin{quotation} {\sl \noindent Maximum size: #1.} \end{quotation}}

\newcommand{\crp}[1]{\begin{quotation} {\sl \noindent For the curve- and network-reconstruction problem: #1} \end{quotation}}

\newcommand{\example}[1]{\begin{quotation} {\sl \noindent Example: #1} \end{quotation}}

%%
% Theorem-Like Environments
%
\newtheorem{defin}{Definition}
  \newenvironment{mydefinition}{\begin{defin} \sl}{\end{defin}}
\newtheorem{theo}[defin]{Theorem}
  \newenvironment{mytheorem}{\begin{theo} \sl}{\end{theo}}
\newtheorem{lem}[defin]{Lemma}
  \newenvironment{lemma}{\begin{lem} \sl}{\end{lem}}
\newtheorem{coro}[defin]{Corollary}
  \newenvironment{corollary}{\begin{coro} \sl}{\end{coro}}
\newtheorem{obse}[defin]{Observation}
  \newenvironment{observation}{\begin{obse} \sl}{\end{obse}}

\newenvironment{proof}{\emph{Proof.}}{\hfill $\Box$ \medskip\\}

% TODO(robwu): Choose a more descriptive title
\title{2D curve and network reconstruction}
\author{
A. van den Boogaart \and
W. Brouwer \and
C. Mens \and
M. Muijsers \and
R. Wu
}
\date{\today}

\begin{document}

\newpage

\maketitle

\begin{abstract}
We present three algorithms that connect all nodes in an unorganised set in the 2D plane in an aestetically pleasing manner. 
The first algorithm will reconstruct a set of nodes into a single curve, such that no lines intersect. 
The second algorithm will create multiple curves from the set of nodes, also in such a way that no lines intersect. 
The third and final algorithm will attempt to create a road network from the nodes, and can add additional nodes when intersections occur.\\

\end{abstract}

\section{Introduction}
\label{se:introduction}
\maxsize{2 pages}
The problem that we attempt to solve is that of reconstructing a set of points back into curves in the 2D plane. 
This problem is split into three different parts. The first two require the reconstruction of a set of points into curves, in the first case there is only one curve, whereas in the second case there are mutiple. The third part of the problem requires reconstructing to a road network.\\
This means that in the second case it is also required to distinguish multiple different curves from each other.\\
 It is important to note that the points are not given in order, since the goal is for the algorithm to determine the order, after which we can connect these points to reconstruct the curve.\\
 The multiple curve problem has the additional problem of finding out which points belong to which curve.\\
 Both algorithms have some constraints; Curve segments should not intersect each other and all points in the input must be used in the curve.\\
The third part of the problem requires reconstruction of a road network. This algorithm could be used to create a road map after data has been collected using the GPS locations of cars.\\
The goal of the algorithm is to create a reasonable representation of the road network, such that a person would agree with the representation that the algorithm gives. As with the other algorithms, there are some constraints.\\
All points need to have at least one possible path to every other point and lines cannot intersect one another, however, unlike with the other problems, points can be added to alleviate intersecting lines.\\
All nodes are points in a 2D plane, given by floating points ranging from 0 to 1. 
The nodes are not determined randomly, but are determined beforehand. In practice, these datasets can be created by laser scanners, or in the case of the network, by following roads and giving the location at some interval.\\

There are multiple known solutions to these problems. One of these is 'The Crust Algorithm' \cite{crust}, which first creates a Voronoi diagram, then uses Delaunay triangulation between the Voronoi diagram and the Voronoi vertices.\\
The Crust Algorithm solves the first problem that is described above, but needs additional work to determine the multiple curve problem.\\
Delaunay triangulation could also be used to create a relatively small set of edges for the third problem, after which a recilinear spanning graph or straight lines can be determined between points.\\
The Crust algorithm is however fairly complicated, and we do not think it is viable to recreate this within the given time.\\
Another algorithm we looked at, that is useful for the single curve reconstruction, is creating a convex hull. A convex hull will create segments between all the outermost points, such that no unconnected point is outside of the enclosed area. Like putting a rubber band around all the points. This can be very useful for the outermost edges, but does not provide a lot of meaningful information.\\
A very useful subgraph that we looked at is the rectilinear spanning tree. This is a minimum spanning tree based on rectilinear distance, which is very much like manhattan distance, and is useful because it already has all the properties that the network reconstruction requires; It connects the points in such a way that there is a path from every node to every other node and there are no intersecting lines. \\

To solve the single curve reconstrution problem, we have chosen for a spider-type algorithm, which will go from point to point and then determines the next best point to go to.\\
The multiple curve reconstruction problem is solved using a weighted spanning tree, and the network reconstruction problem is also solved using a spanning tree, in this case the rectilinear spanning tree.\\
After reconstructing this tree we try to find straight lines and connect those, since a spanning tree will not create cycles.\\
The single curve reconstruction solution has produced good results so far, and has no problems with most inputs.\\
The result of the network reconstruction are not yet complete, we are often missing edges when adding those would add cycles.\\

\newpage
\section{The algorithms}
\label{se:algorithms}

\subsection{Single curve reconstruction}
To solve reconstruction of a single curve, we took an intuitive approach. After analyzing our own train of though when solving our own test cases, it was clear that our brains were trying to start somewhere on the curve, and following the curve along, making sure no points got forgotten in time.\\

We have attempted to utilize a similar method. We implemented a 'spider'-type algorithm that mainly depends on three important steps:
\begin{itemize}
\item Choose a position for the spider to start
\item Let the spider decide where it wants to go next, based on factors
\item Let the spider go there and have it connect the two nodes
\item Go on until the beginning has been reached
\end{itemize}

This interpretation soon raises the question "So how does it make sure no points are forgotten?"\\
When two curves come really close to each other, the spider might feel like a node in the other curve is the best place to go, thus probably completely invalidating the rest of the run.\\

A simple solution for this would be to see at the end whether the found curve is a valid curve, and to rewind to a point where the algorithm likely made the wrong choice.\\

\subsubsection{Naive implementation} 

Attempting to implement this solution, which we will name the Spider algorithm from here on, lead to disappointing results. Analyzing the informal description already soon tells you the running time of a naive implementation will definitely not be $O(n!)$, and this is what we found after implementation.\\

Without the recursive strategy of looking back and trying to find a point where a mistake was made, the algorithm performs quite fine and finds a nice line (sometimes intersecting). With the recursive strategy, the algorithm takes too long to run on any amount of points larger than 100, where the points are considerably random.\\

These observations of the naive implementation lead us to create a more clever version of the Spider algorithm, that supported:
\begin{itemize}
\item Smart choice of a first position
\item Smart choice of next node depending on all available factors
\item A manageable way of remembering possibly valid choices and re-evaluating those choices if necessary
\item A solid way of identifiying mistakes
\end{itemize}


\subsubsection{Choice of first position} 

The first position of the spider will be chosen by picking the most boundary-like point. The most boundary-like point is the point, which has the largest continuous angular interval where no other points lie. So, if the spider were standing on the most boundary-like point, it could look around that whole angular interval and see no points.\\

The first segments are then chosen by taking the two nearest nodes, and since there are then 3 possibilities to form 2 segments (we do not want to form a triangle unless there are only 3 points, of course) we simply take each of them and process each of them, and see which one fails the least.\\

\subsubsection{Choice of next node} 

If the spider is standing at a certain node, it looks back at the nodes it came from, and decides on the expected angle and distance to the next node. The expected angle is a continued value of a linear formula with the previous 2 angles as anchor points, and the expected distance is a continued value of a linear formula with the previous 2 distances as anchor points. In simpler terms: the change in angle and distance between the two last traversed segments is expected to be closely the angle and distance between the last traversed segment and the next to traverse. If the last traversed distances are 4 and 6, the expected next distance will be 8.\\

The nodes are then sorted and stored by their 'likelihood' to be the best successor. Their likelihood is defined as the result of a (chooseable and possibly adaptive) formula that determines how close the observed angle and distance to a point being evaluated is to the expected angle and distance to observe.\\

The node with the best likelihood is then selected to be the successor and the spider moves to that node. (Whether a smaller or greater likelihood means more likely can depend on implementation if it is mathematically easier. We will not speak about the data representation of likelihood except for the fact that we chose to use a float value decreasing if more likely.)\\

The formula that we used for the likelihood is the sum of squares of the following values: the ratio of distance to the expected distance (if smaller than 1, this value is taken to the power -1), and the absolute difference in angle to the expected angle (in fraction of pi).\\

\subsubsection{Remembering possibly valid choices} 

For the whole path taken, per node it is stored what the though process at that point was (a 'viewpoint'): a sorted list of possible nodes to travel to, and their likelihood. When a mistake is made, we can simply look at the difference of the current likelihood to the next likelihood per viewpoint, and choose the one which is most likely incorrect to change.\\

\subsubsection{Identifying mistakes} 

To identify mistakes, we used the following criteria:
\begin{itemize}
\item The node the spider wants to go is VERY likely (a certain factor of difference to the next likelihood) but requires an intersection
\item The last segment would create an intersection, and it not too long to be removed
\item Not all nodes have been taken into account when the last node is reached
\end{itemize}


\subsubsection{Open or closed} 

Finally, we would like to spend a word on the detection of whether a curve is open or closed. We first decided that whether a curve is open or closed depends on the factor between the longest segment length and the one-to-longest segment length: if this is large enough, the curve is probably open and we should remove the longest segment.\\

However, the distances between nodes may vary greatly in parts of the curve. Therefore, we decided on a slighly different alternative: whether a curve is open or closed depends on whether there is a segment, for which the factor between its own length and the lengths of its adjacent segments is higher than a certain number. If so, the segment with such highest factor should be removed.\\

\subsection{Multiple curve reconstruction}
\subsubsection{Background definitions}
%TODO Define Node/Point, Segment/Line Segment, MST?

\subsubsection{Outline}
Our multiple curve reconstruction algorithm is based on findings after an evaluation of how humans find curves in a set of points. By consciously observing ourselves while connecting nodes, we have found that the most important factors in determining whether or not to connect a point to another point are 1) the proximity of other points and 2) line segment patterns in the graph constructed so far.

In order to develop an algorithm that uses these concepts, the most important primitives for building the algorithm have to be identified. This step is important, because an algorithm that yields a perfect solution is useless when it takes ages to calculate the result. The two important factors from the previous paragraph resulted in the following supporting primitives:

\begin{itemize}
\item Adjacency matrix - By calculating an adjacency matrix in advance, the algorithm can find nearby points in constant time.
\item A data structure that provides information about the connected nodes in a graph. In particular:
\begin{itemize}
\item Given a line segment, does it intersect the graph?
\item Given a node, which segments are connected to it?
\item Which nodes in the graph are connected to at most one other node?
\end{itemize}
\end{itemize}

The actual algorithm starts with calculating a minimum spanning tree for all input nodes. Thereafter, nodes that are not yet connected with two other nodes are located and connected to the most appropriate neighbor. These neighbors are found with help of the previously mentioned primitives. Finally, clusters of coherent nodes are separated from other nodes. The details for this algorithm are elaborated in the next section.

\subsubsection{Description}
The algorithm takes a set of $n$ Nodes (with an X and Y coordinate) as input, and yields a set of Segments (a data type with two (x,y) coordinates denoting its endpoints).

At first, an Adjacency matrix is constructed from the set of nodes. This takes $O(n^2)$ time. This matrix is stored in a hashmap that maps nodes to an array of node-distance tuples. This list is sorted in ascending order by the distance between the node and key. Because there are $n$ lists to be sorted, and a comparison-based sorting algorithm is mandatory, the running time of this step is $O(n^2 \log(n))$. After this expensive set-up, queries such as finding the Xth closest node to a node can be answered in constant time.

%TODO Explain next step.

\subsection{Network Algorithm}
\subsubsection{Background definitions}
\begin{itemize}
  \item $\mathbb{R}^2$ is the two dimensional Euclidian space.
  \item $P$ is the given set of points in $\mathbb{R}^2$
  \item $L_1$ distance is the distance between two points in taxicab geometry.
  \item Rectilinear minimum spanning tree $RMST$is the tree spanning all points in $P$ such that the sum of its edge $L_1$ distances is the minimum.
  \item $RN_{min}$ is a minimum reconstruction of the road network that adds missing straight road segments to the $RMST$.
  \item $RN_{com}$ is a complete reconstruction of the road network in which juctions and roundabouts are connected in a correct way.
\end{itemize}
\subsubsection{Outline}

The algorithm consists of the following steps:
\begin{enumerate}
  \item Given a set $V$ of points in $\mathbb{R}^2$ create a graph $G(V,E)$ where $V=P$ and $E=V\times V$.
  \item Compute the $RMST$ of $G$.
  \item Mark points that are only in one segment and find $RN_{min}$.
  \item Find segments with a divergent angle and compute $RN_{com}$.
  \end{enumerate}
  
\subsubsection{Description}
Given the set $V$ of points in $\mathbb{R}^2$ we first generate a graph $G$ in which every point $p\in V$ is connected to every point $q \in V$. Then the algorithms computes the $RMST$, see algorithm \ref{alg:RMSTalg}, using kruskal's algorithm \cite{k-osssgtsp-56}, for $G$ resulting in a connected graph that gives a good approximation of the road network but some straight road segments may not be connected, see figure \ref{fig:RMST}. We now find a set of points $S$ for which every $s \in S$ is a endpoint of a road segment, see algorithm \ref{alg:RNminalg}. For these points a edge $e \in E$ is found such that $e=(s,x)$ where $x \in V$. The slope of the edge determines the direction for the road segment for which $s$ is the endpoint. A line $l_1$ perpendicular to the slope is calculated and it is checked whether a nearby point $x \in V$ is below $l_1$ for $e$ with a negative slope or if $x$ is above $l_1$ for $e$ with a positive slope, see figure \ref{fig:RNmin}. Finally we calculate $RN_{com}$, see algorithm \ref{alg:RNcomalg}. First we find all segments $e \in E$ for which the slope of the following segment $e' \in E$ is divergent. For the segment $e$ we draw a line in the same direction and look for a intersection with a segment $x \in E$, see figure \ref{fig:RNcom}. If the distance between $e$ and $x$ is sufficiently small segment $e'$ is removed from $RN_{min}$ and a new segment from $e$ to $x$ is added to $RN_{com}$.
\\
\begin{figure}
\begin{tikzpicture}
\draw [fill] (7,0.5) circle [radius=0.05];
\draw [fill] (7.5,0.5) circle [radius=0.05];
\draw [fill] (8,0.5) circle [radius=0.05];
\draw [fill] (8.5,0.5) circle [radius=0.05];
\draw [fill] (9,0.5) circle [radius=0.05];
\draw [fill] (9.5,0.5) circle [radius=0.05];
\draw [fill] (10,0.5) circle [radius=0.05];
\draw [fill] (10.5,0.5) circle [radius=0.05];
\draw [fill] (11,0.5) circle [radius=0.05];
\draw [fill] (7,3) circle [radius=0.05];
\draw [fill] (7.5,3) circle [radius=0.05];
\draw [fill] (8,3) circle [radius=0.05];
\draw [fill] (8.5,3) circle [radius=0.05];
\draw [fill] (9,3) circle [radius=0.05];
\draw [fill] (9.5,3) circle [radius=0.05];
\draw [fill] (10,3) circle [radius=0.05];
\draw [fill] (10.5,3) circle [radius=0.05];
\draw [fill] (11,3) circle [radius=0.05];
\draw [fill] (8,0) circle [radius=0.05];
\draw [fill] (8,1) circle [radius=0.05];
\draw [fill] (8,1.5) circle [radius=0.05];
\draw [fill] (8,2) circle [radius=0.05];
\draw [fill] (8,2.5) circle [radius=0.05];
\draw [fill] (8,3.5) circle [radius=0.05];
\draw [fill] (10,0) circle [radius=0.05];
\draw [fill] (10,1) circle [radius=0.05];
\draw [fill] (10,1.5) circle [radius=0.05];
\draw [fill] (10,2.5) circle [radius=0.05];
\draw [fill] (10,3.5) circle [radius=0.05];

\draw (7,0.5) --(11,0.5);
\draw (7,3) --(11,3);
\draw (8,0) --(8,3.5);
\draw (10,0) --(10,1.5);
\draw (10,2.5) --(10,3.5);

\draw [color=red] (10,2) circle[radius=0.8];


\end{tikzpicture}
\caption{$RMST$ for $P$ with a missing road segment indicated by the red circle.}
\label{fig:RMST}
\end{figure}

\begin{figure}
\begin{tikzpicture}
\draw [fill] (7,0.5) circle [radius=0.05];
\draw [fill] (7.5,0.5) circle [radius=0.05];
\draw [fill] (8,0.5) circle [radius=0.05];
\draw [fill] (8.5,0.5) circle [radius=0.05];
\draw [fill] (9,0.5) circle [radius=0.05];
\draw [fill] (9.5,0.5) circle [radius=0.05];
\draw [fill] (10,0.5) circle [radius=0.05];
\draw [fill] (10.5,0.5) circle [radius=0.05];
\draw [fill] (11,0.5) circle [radius=0.05];
\draw [fill] (7,3) circle [radius=0.05];
\draw [fill] (7.5,3) circle [radius=0.05];
\draw [fill] (8,3) circle [radius=0.05];
\draw [fill] (8.5,3) circle [radius=0.05];
\draw [fill] (9,3) circle [radius=0.05];
\draw [fill] (9.5,3) circle [radius=0.05];
\draw [fill] (10,3) circle [radius=0.05];
\draw [fill] (10.5,3) circle [radius=0.05];
\draw [fill] (11,3) circle [radius=0.05];
\draw [fill] (8,0) circle [radius=0.05];
\draw [fill] (8,1) circle [radius=0.05];
\draw [fill] (8,1.5) circle [radius=0.05];
\draw [fill] (8,2) circle [radius=0.05];
\draw [fill] (8,2.5) circle [radius=0.05];
\draw [fill] (8,3.5) circle [radius=0.05];
\draw [fill] (10,0) circle [radius=0.05];
\draw [fill] (10,1) circle [radius=0.05];
\draw [fill] (10,1.5) circle [radius=0.05];
\draw [fill] (10,2.5) circle [radius=0.05];
\draw [fill] (10,3.5) circle [radius=0.05];

\draw (7,0.5) --(11,0.5);
\draw (7,3) --(11,3);
\draw (8,0) --(8,3.5);
\draw (10,0) --(10,3.5);

\draw [fill] (12.5,1) circle [radius=0.05];
\draw [fill] (13,1.5) circle [radius=0.05];
\draw [fill] (13.5,2) circle [radius=0.05];
\draw [fill] (14,2.5) circle [radius=0.05];

\draw (12.5,1) --(13.5,2);
\draw [color=red] (13,2.5) --(14,1.5);
\node at (14,1.3) {$l_1$};
\node at (14,2.8) {$x$};
\node at (13.1,1.8) {$e$};

\draw [fill] (16.5,2.5) circle [radius=0.05];
\draw [fill] (17,2) circle [radius=0.05];
\draw [fill] (17.5,1.5) circle [radius=0.05];
\draw [fill] (18,1) circle [radius=0.05];

\draw (16.5,2.5) --(17.5,1.5);
\draw [color=red] (17,1) --(18,2);
\node at (17,0.8) {$l_1$};
\node at (18.3,1) {$x$};
\node at (17.2,2) {$e$};


\draw [color=red] (10,2) circle[radius=0.8];
\end{tikzpicture}
\caption{Left: $RN_{min}$ road segment in circle is connected. Middle: Slope of $e$ is positive, check if $x$ is above $l_1$. Right: Slope of $e$ is negative, check if $x$ is below $l_1$.}
\label{fig:RNmin}
\end{figure}

\begin{figure}
\begin{tikzpicture}
\draw (7,0.5) --(7.5,0.5);
\draw [color=red](7.5,0.5) --(8,1);
\draw (8,1) --(8,0);
\node at (7.7,1) {$e'$};

\draw [fill] (7,0.5) circle [radius=0.05];
\draw [fill] (7.5,0.5) circle [radius=0.05];
\draw [fill] (8,1) circle [radius=0.05];
\draw [fill] (8,0) circle [radius=0.05];


\draw (13,0.5) --(13.5,0.5);
\draw [color=blue] (13.5,0.5) --(15,0.5);
\draw [color=red](13.5,0.5) --(14,1);
\draw (14,1) --(14,0);
\node at (13.7,1) {$e'$};
\node at (14.2,0.3) {$p$};

\draw [fill] (13,0.5) circle [radius=0.05];
\draw [fill] (13.5,0.5) circle [radius=0.05];
\draw [fill] (14,1) circle [radius=0.05];
\draw [fill] (14,0) circle [radius=0.05];
\draw [color=red, fill] (14,0.5) circle [radius=0.05];

\draw (19,0.5) --(19.5,0.5);
\draw [color=red] (19.5,0.5) --(20,0.5);
\draw (20,1) --(20,0);
\node at (20.2,0.3) {$p$};

\draw [fill] (19,0.5) circle [radius=0.05];
\draw [fill] (19.5,0.5) circle [radius=0.05];
\draw [fill] (20,1) circle [radius=0.05];
\draw [fill] (20,0) circle [radius=0.05];
\draw [color=red, fill] (20,0.5) circle [radius=0.05];

\end{tikzpicture}
\caption{Calculation steps for $RN_{com}$. Left: Edge $e'$ with divergent angle in red. Middle: Blue line intersects at $p$. Right:$e'$ is remove from $RN_{min}$ and new edge $s$ is added to $RN_{com}$ }
\label{fig:RNcom}
\end{figure}

\begin{algorithm}
\caption{Calculate $RMST$ for graph $G(V,E)$}
\begin{algorithmic} 
\STATE $A=\emptyset$
\STATE Sort by increasing $L_1$ distance($E$)
\FORALL{$v \in V$} 
\STATE MAKE-SET($v$)
\ENDFOR
\FORALL{$u$, $v \in E$}
\IF{FIND-SET($u$) $\neq$ FIND-SET($v$)}
\STATE $A=A$ $\cup$ \{($u,v$)\} 
\STATE UNION($u,v$)
\ENDIF
\ENDFOR
\RETURN $A$
\end{algorithmic}
\label{alg:RMSTalg}
\end{algorithm}

\begin{algorithm}
\caption{Calculate $RN_{min}$ for $RMST(V,E)$}
\begin{algorithmic} 
\STATE $A= RMST$
\FORALL{$v\in V$}
\IF{$v$ is a endpoint \textbf{and} adjacentnodes($v$) $\neq$ $\emptyset$}
\STATE $e$ = FIND-SEGMENT($V$)
\REPEAT 
\IF{adjacentnodes[i].direction $=$ $e$.direction }
\STATE $A$.add(new Segment($e$,adjacentnodes[i]))
\ENDIF
\STATE i++
\UNTIL{new segment is added}
\ENDIF
\ENDFOR
\RETURN $A$
\end{algorithmic}
\label{alg:RNminalg}
\end{algorithm}

\begin{algorithm}
\caption{Calculate $RN_{com}$ given $RN_{min})$}
\begin{algorithmic} 
\STATE $A= RN_{min}$
\FORALL{$e \in E$}
\STATE $e'$ = $e$.NEXT-SEGMENT
\IF{$e'$.getSlope $\neq$ $e$.getSlope}
\IF{Direction $e$ intersect with segment $x \in E$}
\IF{Distance between $e$ and $x$ $<$ 0.2f}
\STATE $p$ = new Point at intersection with $x$
\STATE $A=A-e'$
\STATE $s$= new Segment from $e$ to $p$
\STATE $A=A+s$
\ENDIF
\ENDIF
\ENDIF
\ENDFOR
\RETURN $A$
\end{algorithmic}
\label{alg:RNcomalg}
\end{algorithm}

\bibliographystyle{plain}

\begin{thebibliography}{50}

\bibitem{crust}
Nina Amenta, Marshall Bern, Manolis Kamvysselis.
A new Voronoi-Based Surface Reconstruction Algorithm
(1998).

\end{thebibliography}







\end{document}

